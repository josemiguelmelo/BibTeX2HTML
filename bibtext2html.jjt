options {
	UNICODE_INPUT=true;
}

PARSER_BEGIN(BibTex)

import java.util.*;

public class BibTex {
	private static String fileToParse;


	public String paramName;

	private static Semantic semantic;

	private static ArrayList<String> nodeIds;

	private static int errorsFound;


	public static void main(String args[]) throws ParseException {

		semantic = new Semantic();
		nodeIds = new ArrayList<String>();
		errorsFound = 0;

		fileToParse = args[0];
		java.io.FileInputStream file;
		try{
			file = new java.io.FileInputStream(fileToParse);
		} catch(java.io.FileNotFoundException e) {
          System.out.println ("The file was not found.");
          return;
        }

        BibTex parser = new BibTex(file);
		SimpleNode root = parser.Start();

		//root.dump("");
		parser.eval(root);
		// cross ref evaluation
		parser.evalCrossref(root);

		System.out.println("\nParse Finished.\nNumber of errors found: "+ errorsFound);
	}

	public HashMap<String, String> getBodyParams(SimpleNode bodyNode){
		HashMap<String, String> params = new HashMap<String, String>();
		for(int i = 0; i < bodyNode.jjtGetNumChildren() ; i++){
			SimpleNode param = (SimpleNode) bodyNode.jjtGetChild(i);

			if(param.jjtGetNumChildren()!=0){
				SimpleNode paramChildNode = (SimpleNode) param.jjtGetChild(0);
				String paramName = paramChildNode.paramName;
				String paramValueClean = semantic.cleanTokens((String)paramChildNode.value);
				//System.out.println(paramValueClean);
				params.put(paramName, paramValueClean);
			}
		}
		return params;
	}

	/**
	* This function is called whenever a class/body pair is found in the tree
	* Evaluates each crossref reference found
	*/
	public int evalCrossrefExpression(SimpleNode classNode, SimpleNode bodyNode, SimpleNode parentNode){
		SimpleNode classChildNode = (SimpleNode) classNode.jjtGetChild(0);
		String className = classChildNode.className;

		HashMap<String, String> bodyParams = getBodyParams(bodyNode);

		if(semantic.validateCrossref(bodyParams, nodeIds, parentNode) == false){
			errorsFound++;
		}
		return 0;
	}

	/**
	* Same methodology of the eval function
	* Runs through the tree and checks if the references found are valid
	*/
	public int evalCrossref(SimpleNode node){
		//ended evaluation
		if(node.jjtGetNumChildren() == 0)
			return 0;
		//root node
		else if(node.jjtGetNumChildren() == 1){
			SimpleNode childNode = (SimpleNode) node.jjtGetChild(0);
			return this.evalCrossref(childNode);
		}
		// Class / Body pair, required to check if it is properly built
		else if(node.jjtGetNumChildren() == 2 && ((SimpleNode)node.jjtGetChild(0)).toString() == "Class" && 
			((SimpleNode)node.jjtGetChild(1)).toString() == "Body" ){

			SimpleNode classChild = (SimpleNode) node.jjtGetChild(0); // class
			SimpleNode bodyChild = (SimpleNode) node.jjtGetChild(1); // body

			return this.evalCrossrefExpression(classChild, bodyChild, node);
		}

		for(int i = 0 ; i < node.jjtGetNumChildren() ; i++)
		{
			this.evalCrossref((SimpleNode) node.jjtGetChild(i));
		}

		return 0;
	}

	/**
	* This function is called whenever a class/body pair is found in the tree
	* Evaluates each parameter of body for the specified class
	*/
	public int evalLanguage(SimpleNode classNode, SimpleNode bodyNode, SimpleNode parentNode)
	{
		SimpleNode classChildNode = (SimpleNode) classNode.jjtGetChild(0);
		String className = classChildNode.className;

		HashMap<String, String> bodyParams = getBodyParams(bodyNode);

		//checks if the parameters found are enough to properly build the specified class
		if(semantic.evalParams(bodyParams, className, parentNode) == false){
			errorsFound++;
		}
		return 0;
	}

	public int eval(SimpleNode node)
	{
		//if no longer has chields, ends the evaluation
		if(node.jjtGetNumChildren() == 0)
			return 0;
		//if has 1 node, it is the root none and proceeds the evaluation
		else if(node.jjtGetNumChildren() == 1){
			SimpleNode childNode = (SimpleNode) node.jjtGetChild(0);
			return this.eval(childNode);
		}
		//if has 2 nodes, it is the Class / Body , and calls evalLanguage to properly evaluate them
		else if(node.jjtGetNumChildren() == 2 && ((SimpleNode)node.jjtGetChild(0)).toString() == "Class" && 
			((SimpleNode)node.jjtGetChild(1)).toString() == "Body" ){

			// add language node id to array list with all IDs;
			String nodeId = node.nodeId;
			if(nodeIds.contains(nodeId)){
				System.out.println("Error: Duplicated id. (Line : " + node.lineNumber + ")");	
				errorsFound++;
			}
			nodeIds.add(nodeId);
			
			SimpleNode classChild = (SimpleNode) node.jjtGetChild(0); // class
			SimpleNode bodyChild = (SimpleNode) node.jjtGetChild(1); // body

			return this.evalLanguage(classChild, bodyChild, node);
		}

		for(int i = 0 ; i < node.jjtGetNumChildren() ; i++)
		{
			this.eval((SimpleNode) node.jjtGetChild(i));
		}

		return 0;
	}
}

PARSER_END(BibTex)

SKIP :
{
	" " | "\t" | "\r" | "\n"
}

TOKEN :
{
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< EQUAL : "=" > |
	< CONCAT : "#" > |
	< QUOTE : "\"" > |
	< COMMA : "," > |
	< ARTICLE : "@article" > | 
	< BOOK : "@book" > |
	< BOOKLET : "@booklet" > |
	< CONFERENCE : "@conference" > |
	< INBOOK : "@inbook" > |
	< INCOLLECTION : "@incollection" > |
	< INPROCEEDINGS : "@inproceedings" > |
	< MANUAL : "@manual" > |


	< MASTERTHESIS : "@masterthesis" > |
	< MISC : "@misc" > |
	< PHDTHESIS : "@phdthesis" > |
	< PROCEEDINGS : "@proceedings" > |
	< TECHREPORT : "@techreport" > |
	< UNPUBLISHED : "@unpublished" > |
	< AUTHOR : "author" > |
	< TITLE : "title" > |
	< YEAR : "year" > |
	< NUMBER : "number" > |
	< PAGES : "pages" > |
	< MONTH : "month" > |
	< NOTE : "note" > |
	< KEY : "key" > |
	< EDITOR : "editor" > |
	< PUBLISHER : "publisher" > |


	< ADDRESS : "address" > |
	< SERIES : "series" > |
	< EDITION : "edition" > |
	< HOWPUBLISHED : "howpublished" > |
	< CHAPTER : "chapter" > |
	< TYPE : "type" > |
	< ANNOTE : "annote" > |
	< BOOKTITLE : "booktitle" > |
	< CROSSREF : "crossref" > |
	< INSTITUTION : "institution" > |
	< JOURNAL : "journal" > |
	< ORGANIZATION : "organization" > |
	< SCHOOL : "school" > |
	< VOLUME : "volume" > |
	< DIGITS : (["0" - "9"])+ > |
	< SPECIFIC_CHAR : ( ("\\" ("\u2018" | "\u201D" | "\u002E" | "\u0048" | "\u0064" | "\u2019" | "\u007E" | "\u0075" | "\u0062" | "\u005E" | "\u003D" | "\u0076" | "\u0063" ) <OPEN_BRACKET>["a"-"z","A"-"Z"]<CLOSE_BRACKET> ) 
					| ("\\" "\u0074" "{"["a"-"z","A"-"Z"]["a"-"z","A"-"Z"]"}") ) >
}

TOKEN : 
{
	< SPECIAL_CHAR : <OPEN_BRACKET> <SPECIFIC_CHAR> <CLOSE_BRACKET> >
}

TOKEN :
{
	< PAGESINPUT : <QUOTE> <DIGITS>(("-"|"--")<DIGITS>)? <QUOTE> >
}

TOKEN :
{
	< STRING : (( <QUOTE> (["a"-"z", "A"-"Z"," ", "-"]|<DIGITS>|<SPECIAL_CHAR>)+ <QUOTE>) 
		| (["a"-"z", "A"-"Z", "-"]|<DIGITS>|<SPECIAL_CHAR>)+
		| ( <OPEN_BRACKET> (["a"-"z", "A"-"Z"," ", "-"]|<DIGITS>|<SPECIAL_CHAR>)+ <CLOSE_BRACKET>))>
}


SimpleNode Start() : {}
{
	Expr() {return jjtThis;}
}

void Expr() : {}
{
	(Language())*
}


/** 
 *****    ****** BibTex Params  **** ******
**/


void Author(): {Token input;} 
{
	<AUTHOR> <EQUAL> input = <STRING>

	{jjtThis.paramName = "author";}
	{jjtThis.value = input.image;}
}

void Title():{Token input;}
{
	<TITLE> <EQUAL> input = <STRING>
	{jjtThis.paramName = "title";}
	{jjtThis.value = input.image;}
}

void Year():{Token input;}
{
	<YEAR> <EQUAL> input = <DIGITS> 
	{jjtThis.paramName = "year";}
	{jjtThis.value = input.image;}
}


void Pages():{Token input;}
{
	<PAGES> <EQUAL> input = <PAGESINPUT>

	{jjtThis.paramName = "pages";}
	{jjtThis.value = input.image;}
}
	

void Month():{Token input;}
{
	<MONTH> <EQUAL> input = <STRING>
	{jjtThis.paramName = "month";}
	{jjtThis.value = input.image;}
}
	

void Note():{Token input;}
{
	<NOTE> <EQUAL> input = <STRING>
	{jjtThis.paramName = "note";}
	{jjtThis.value = input.image;}
}
	

void Key():{Token input;}
{
	<KEY> <EQUAL> input = <STRING>
	{jjtThis.paramName = "key";}
	{jjtThis.value = input.image;}
}
	
	
void Editor():{Token input;}
{
	<EDITOR> <EQUAL> input = <STRING>
	{jjtThis.paramName = "editor";}
	{jjtThis.value = input.image;}
}
	
void Publisher(): {Token input;}
{
	<PUBLISHER> <EQUAL> input = <STRING>
	{jjtThis.paramName = "publisher";}
	{jjtThis.value = input.image;}
}

void Number():{Token input;}
{
	<NUMBER> <EQUAL> input = <DIGITS> 
	{jjtThis.paramName = "number";}
	{jjtThis.value = input.image;}
}


void Address():{Token input;}
{
	<ADDRESS> <EQUAL> input = <STRING>
	{jjtThis.paramName = "address";}
	{jjtThis.value = input.image;}
}

void Series():{Token input;}
{
	<SERIES> <EQUAL> input = <STRING>
	{jjtThis.paramName = "series";}
	{jjtThis.value = input.image;}
}

void Edition():{Token input;}
{
	<EDITION> <EQUAL> input = <STRING>
	{jjtThis.paramName = "edition";}
	{jjtThis.value = input.image;}
}

void HowPublished():{Token input;}
{
	<HOWPUBLISHED> <EQUAL> input = <STRING>
	{jjtThis.paramName = "howpublished";}
	{jjtThis.value = input.image;}
}

void Chapter():{Token input;}
{
	<CHAPTER> <EQUAL> input = <STRING>
	{jjtThis.paramName = "chapter";}
	{jjtThis.value = input.image;}
}

void Type():{Token input;}
{
	<TYPE> <EQUAL> input = <STRING>
	{jjtThis.paramName = "type";}
	{jjtThis.value = input.image;}
}


void Annote():{Token input;}
{
    <ANNOTE> <EQUAL> input = <STRING>
	{jjtThis.paramName = "annote";}
	{jjtThis.value = input.image;}
}

void BookTitle():{Token input;}
{
    <BOOKTITLE> <EQUAL> input = <STRING>
	{jjtThis.paramName = "booktitle";}
	{jjtThis.value = input.image;}
}

void CrossRef():{Token input;}
{
    <CROSSREF> <EQUAL> input = <STRING>
	{jjtThis.paramName = "crossref";}
	{jjtThis.value = input.image;}
}

void Institution():{Token input;}
{
    <INSTITUTION> <EQUAL> input = <STRING>
	{jjtThis.paramName = "institution";}
	{jjtThis.value = input.image;}
}

void Journal():{Token input;}
{
    <JOURNAL> <EQUAL> input = <STRING>
	{jjtThis.paramName = "journal";}
	{jjtThis.value = input.image;}
}
void Organization():{Token input;}
{
    <ORGANIZATION> <EQUAL> input = <STRING>
	{jjtThis.paramName = "organization";}
	{jjtThis.value = input.image;}
}

void School():{Token input;}
{
    <SCHOOL> <EQUAL> input = <STRING>
	{jjtThis.paramName = "school";}
	{jjtThis.value = input.image;}
}

void Volume():{Token input;}
{
    <VOLUME> <EQUAL> input = <STRING>
	{jjtThis.paramName = "volume";}
	{jjtThis.value = input.image;}
}


/** 
 *****    ****** BibTex Classes  **** ******
**/
	
void Article() :{}
{
	<ARTICLE>
	{jjtThis.className = "article";}
}

void Book() :{}
{
	<BOOK>
	{jjtThis.className = "book";}
}

void Booklet() :{}
{
	<BOOKLET>
	{jjtThis.className = "booklet";}
}

void Conference() :{}
{
	<CONFERENCE>
	{jjtThis.className = "conference";}
}
void Inbook() :{}
{
	<INBOOK>
	{jjtThis.className = "inbook";}
}

void Incollection() :{}
{
	<INCOLLECTION>
	{jjtThis.className = "incollection";}
}
void Inproceedings() :{}
{
	<INPROCEEDINGS>
	{jjtThis.className = "inproceedings";}
}

void Manual() :{}
{
	<MANUAL>
	{jjtThis.className = "manual";}
}


void Masterthesis() :{}
{
	<MASTERTHESIS>
	{jjtThis.className = "masterthesis";}
}

void Misc() :{}
{
	<MISC>
	{jjtThis.className = "misc";}
}

void PhdThesis() :{}
{
	<PHDTHESIS>
	{jjtThis.className = "phdthesis";}
}
void Proceedings() :{}
{
	<PROCEEDINGS>
	{jjtThis.className = "proceedings";}
}
void TechReport() :{}
{
	<TECHREPORT>
	{jjtThis.className = "techreport";}
}
void Unpublished() :{}
{
	<UNPUBLISHED>
	{jjtThis.className = "unpublished";}
}


/** 
 *** **** ** ** Language Class **** * ***** ** **
 **/
void Class() : {}
{
	Article() | Book() | Booklet() | Conference() | Inbook() | Incollection() | Inproceedings() | Manual() | Masterthesis() |
	Misc() | PhdThesis() | Proceedings() | TechReport() | Unpublished()
}

/** 
 *** **** ** ** Language Body **** * ***** ** **
 **/
void Body():{}
{
	(<COMMA>
	(Params())?
	)*
}

/** 
 *** **** ** ** Language Params **** * ***** ** **
 **/
void Params(): {}
{
	(Author() | Title() | Year() | Number() | Pages() | Month() | Note() | Key() | Editor() | Publisher() | Address() | Series() |
	Edition() | HowPublished() | Chapter() | Type() | Annote() | BookTitle() | CrossRef() | Institution() | Journal() | Organization() |
	School() | Volume())
}

JAVACODE
void ErrorSkipLine(Token id) {
	Token t;
	t = getToken(0);

	System.out.println("Error: Invalid syntax at line " + t.beginLine);
	t = getNextToken();


	errorsFound++;
}

void Language() : {Token id;}
{
	{ jjtThis.paramName = "language"; }
	Class()
	<OPEN_BRACKET>
	id = <STRING>

	{jjtThis.lineNumber = id.beginLine;}
	{jjtThis.nodeId = id.image; }

	try{
		Body() 
	}catch(Exception e){
		ErrorSkipLine(id);
	}
	<CLOSE_BRACKET>
}

